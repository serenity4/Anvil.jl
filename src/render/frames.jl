mutable struct WindowState
    swapchain::SwapchainKHR
    swapchain_ci::SwapchainCreateInfoKHR
    render_pass::RenderPass
    fb_imgs::Vector{Image}
    fb_views::Vector{ImageView}
    fbs::Vector{Framebuffer}
end

function Vulkan.SurfaceCapabilitiesKHR(ws::WindowState)
    unwrap(get_physical_device_surface_capabilities_khr(ws.render_pass.device.physical_device, ws.swapchain.surface))
end

function update!(ws::WindowState)
    @unpack swapchain, render_pass = ws
    device = render_pass.device

    # TODO: fix in Vulkan.jl
    _extent = SurfaceCapabilitiesKHR(ws).current_extent.vks
    new_extent = Extent2D(_extent.width, _extent.height)

    if new_extent â‰  ws.swapchain_ci.image_extent # regenerate swapchain
        ws.swapchain_ci = setproperties(ws.swapchain_ci, old_swapchain = swapchain, image_extent = new_extent)
        ws.swapchain = unwrap(create_swapchain_khr(device, ws.swapchain_ci))
    end

    fb_imgs = unwrap(get_swapchain_images_khr(device, swapchain))

    fb_views = map(fb_imgs) do img
        ImageView(
            device,
            img,
            IMAGE_VIEW_TYPE_2D,
            ws.swapchain_ci.image_format,
            ComponentMapping(fill(COMPONENT_SWIZZLE_IDENTITY, 4)...),
            ImageSubresourceRange(IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1),
        )
    end

    fbs = map(fb_views) do view
        Framebuffer(device, ws.render_pass, [view], new_extent.width, new_extent.height, 1)
    end

    @pack! ws = fb_imgs, fb_views, fbs
end

function WindowState(swapchain::SwapchainKHR, swapchain_ci::SwapchainCreateInfoKHR, render_pass::RenderPass)
    ws = WindowState(swapchain, swapchain_ci, render_pass, [], [], [])
    update!(ws)
    ws
end

"""
State necessary to execute draw and presentation commands at every frame.
"""
mutable struct FrameState
    device::Device
    ws::WindowState
    frame::Int
    "1-based indexing."
    img_idx::Int
    img_rendered::Vector{Semaphore}
    img_acquired::Vector{Semaphore}
    hasrendered::Vector{Fence}
    max_in_flight::Int
end

function FrameState(device::Device, ws::WindowState)
    max_in_flight = ws.swapchain_ci.min_image_count
    FrameState(
        device,
        ws,
        0,
        1,
        map(x -> Semaphore(device), 1:max_in_flight),
        map(x -> Semaphore(device), 1:max_in_flight),
        map(x -> Fence(device; flags = FENCE_CREATE_SIGNALED_BIT), 1:max_in_flight),
        max_in_flight,
    )
end

"""
    command_buffers(renderer, frame, app)

Command buffers generated by the application.
"""
function command_buffers end

function next_frame!(fs::FrameState, rdr::BasicRenderer, app)
    swapchain = fs.ws.swapchain

    # acquire next image
    old_idx = fs.img_idx
    status = @timeit to "Acquire next image" acquire_next_image_khr(fs.device, fs.ws.swapchain, typemax(UInt64); semaphore = fs.img_acquired[old_idx])
    if !iserror(status)
        idx, result = unwrap(status)
        @assert result in (SUCCESS, SUBOPTIMAL_KHR) "$result: Could not retrieve next swapchain image"
        fs.frame += 1
        fs.img_idx = idx + 1

        # submit rendering commands
        @timeit to "Submit rendering commands" begin
            cbuffs = @timeit to "Create command buffers" command_buffers(rdr, fs, app)
            img_acquired_info = SemaphoreSubmitInfoKHR(fs.img_acquired[old_idx], 0, 0; stage_mask = PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR)
            img_rendered_info = SemaphoreSubmitInfoKHR(fs.img_rendered[fs.img_idx], 0, 0; stage_mask = PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR)
            render_info = SubmitInfo2KHR([img_acquired_info], CommandBufferSubmitInfoKHR.(cbuffs, 0), [img_rendered_info])
            @timeit to "Wait for frame being rendered" wait_for_fences(fs.device, [fs.hasrendered[fs.img_idx]], false, 10_000_000_000)
            reset_fences(fs.device, [fs.hasrendered[fs.img_idx]])
            submit(rdr, [render_info]; fence = fs.hasrendered[fs.img_idx])
        end

        # submit presentation commands
        @timeit to "Submit presentation commands" begin
            present_info = PresentInfoKHR([fs.img_rendered[fs.img_idx]], [swapchain], [fs.img_idx - 1])
            if swapchain == fs.ws.swapchain # no window state changes, present the image
                @timeit to "Present frame" present(rdr, present_info)
            else # start over
                next_frame!(fs, rdr)
            end
        end
    else
        @timeit to "Recreate swapchain" begin
            err = unwrap_error(status)
            if err.code == ERROR_OUT_OF_DATE_KHR
                # recreate swapchain and start over
                update!(fs.ws)
                next_frame!(fs, rdr, app)
            end
        end
    end
end

function wait_hasrendered(fs::FrameState)
    wait_for_fences(fs.device, fs.hasrendered, true, 10_000_000_000)
end
